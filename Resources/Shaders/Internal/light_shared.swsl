preset raw;

#include "/Shaders/Internal/shadow_cast_shared.swsl"

const highp float LIGHTING_HEIGHT = 1.0;

const highp float g_MinVariance = 0.0;

varying highp vec2 worldPosition;

uniform highp vec4 lightColor;
// Position of the light, in world coordinates.
uniform highp vec2 lightCenter;
uniform highp vec2 eyeCenter;
uniform highp vec2 eyeZoom;
uniform highp float lightRange;
uniform highp float lightPower;
uniform highp float lightSoftness;
uniform highp float lightIndex;
uniform highp float globalRotation;
uniform sampler2D shadowMap;
uniform sampler2D normalMap;

void vertex()
{
    highp vec3 transformed = modelMatrix * vec3(VERTEX, 1.0);
    worldPosition = transformed.xy;
    transformed = projectionMatrix * viewMatrix * transformed;

    VERTEX = transformed.xy;
}

highp vec2 rotateVector(highp vec2 vector, highp float theta)
{
    return vec2(vector.x * cos(theta) - vector.y * sin(theta), vector.x * sin(theta) + vector.y * cos(theta));
}

highp float shadowContrib(highp vec2 diff)
{
    highp float dist = length(diff);

    return smoothstep(0.0, 1.0, ChebyshevUpperBound(occludeDepth(diff, shadowMap, lightIndex), dist));
}

void fragment()
{
    highp float mask = zTexture(UV).r;

    highp vec2 diff = worldPosition - lightCenter;

    // Totally not hacky PCF on top of VSM.
    highp float occlusion = lightIndex < 0.0 ? 1.0 : createOcclusion(diff);

    if (occlusion == 0.0)
    {
        discard;
    }

    highp float dist = dot(diff, diff) + LIGHTING_HEIGHT;
    highp float val = clamp((1.0 - clamp(sqrt(dist) / lightRange, 0.0, 1.0)) * (1.0 / (sqrt(dist + 1.0))), 0.0, 1.0);

    val *= lightPower;
    val *= mask;

    // how this works
    // globalRotation: rotation of the eye minus rotation of the light minus rotation of the map
    // eyeCenter: center of the eye plus offset
    // eyeZoom: zoom of the eye divided by viewport scale
    // UV is on a scale from 0 to 1 in x and y axes

    // normalize diff and rotate it by globalRotation radians counterclockwise
    highp vec2 lightDir = rotateVector(normalize(diff), globalRotation);

    // take UV, center it at 0.5, 0.5, add the difference between lightCenter and eyeCenter,
    // flip it upside down, divide it by 2, divide it by lightRange, and rotate it
    // by globalRotation radians clockwise
    highp vec2 newUV = rotateVector(UV - vec2(0.5, 0.5) + (lightCenter - eyeCenter) / vec2(2, -2) / lightRange, -globalRotation);

    // multiply newUV by the x and y components of projectionMatrix, flip it upside down again,
    // and divide it by eyeZoom, before multiplying by lightRange
    newUV *= (projectionMatrix * vec3(1, 1, 0)).xy * vec2(1, -1) / eyeZoom * lightRange;

    // center newUV at 0, 0 instead of 0.5, 0.5
    newUV += vec2(0.5, 0.5);
    highp vec4 origSample = texture2D(normalMap, newUV);

    // origSample is on the range 0 - 1 in all components,
    // so we multiply the x and y by 2, then subtract a certain value
    // to make sure original values of 0.5, 0.5 go to 0, 0
    highp vec4 normalSample = origSample * vec4(2,2,1,1) - vec4(0.441, 0.441, 0, 0);
    highp float run = 1;
    if (origSample.xyzw != vec4(0,0,0,1))
    {
        run = -dot(lightDir, normalSample.xy);
        if (run <= 0)
            run = 0;
        run += normalSample.z * normalize(vec3(diff, LIGHTING_HEIGHT)).z;
        if (run <= 0)
            discard;
    }

    COLOR = vec4(lightColor.xyz, val * occlusion * run);
}

