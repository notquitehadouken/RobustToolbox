preset raw;

#include "/Shaders/Internal/shadow_cast_shared.swsl"

const highp float LIGHTING_HEIGHT = 1.0;

const highp float g_MinVariance = 0.0;

varying highp vec2 worldPosition;

uniform highp vec4 lightColor;
// Position of the light, in world coordinates.
uniform highp vec2 lightCenter;
uniform highp vec2 eyeCenter;
uniform highp vec2 eyeZoom;
uniform highp float lightRange;
uniform highp float lightPower;
uniform highp float lightSoftness;
uniform highp float lightIndex;
uniform highp float globalRotation;
uniform highp float viewportScale;
uniform sampler2D shadowMap;
uniform sampler2D normalMap;

void vertex()
{
    highp vec3 transformed = modelMatrix * vec3(VERTEX, 1.0);
    worldPosition = transformed.xy;
    transformed = projectionMatrix * viewMatrix * transformed;

    VERTEX = transformed.xy;
}

highp vec2 rotateVector(highp vec2 vector, highp float theta)
{
    return vec2(vector.x * cos(theta) - vector.y * sin(theta), vector.x * sin(theta) + vector.y * cos(theta));
}

highp float shadowContrib(highp vec2 diff)
{
    highp float dist = length(diff);

    return smoothstep(0.0, 1.0, ChebyshevUpperBound(occludeDepth(diff, shadowMap, lightIndex), dist));
}

void fragment()
{
    highp float mask = zTexture(UV).r;

    highp vec2 diff = worldPosition - lightCenter;

    // Totally not hacky PCF on top of VSM.
    highp float occlusion = lightIndex < 0.0 ? 1.0 : createOcclusion(diff);

    if (occlusion == 0.0)
    {
        discard;
    }

    highp float dist = dot(diff, diff) + LIGHTING_HEIGHT;
    highp float val = clamp((1.0 - clamp(sqrt(dist) / lightRange, 0.0, 1.0)) * (1.0 / (sqrt(dist + 1.0))), 0.0, 1.0);

    val *= lightPower;
    val *= mask;

    highp vec2 lightDir = rotateVector(normalize(diff), globalRotation);
    highp vec2 newUV = rotateVector(UV - vec2(0.5, 0.5) + (lightCenter - eyeCenter) / vec2(2, -2) / lightRange, -globalRotation);
    newUV *= (projectionMatrix * vec3(1, 1, 0)).xy * vec2(1, -1) / eyeZoom;
    newUV *= lightRange;
    newUV += vec2(0.5, 0.5);
    highp vec4 origSample = texture2D(normalMap, newUV);
    if (origSample.xy == vec2(0.5, 0.5))
    {
        COLOR = vec4(1,1,1,100);
    }
    highp vec4 normalSample = origSample * vec4(2,2,1,1) - vec4(0.441, 0.441, 0, 0);
    highp float run = 1;
    if (origSample.xyzw != vec4(0,0,0,1))
    {
        run = -dot(lightDir, normalSample.xy);
        if (run <= 0)
            run = 0;
        run += normalSample.z * normalize(vec3(diff, LIGHTING_HEIGHT)).z;
        if (run <= 0)
            discard;
    }

    COLOR = vec4(lightColor.xyz, val * occlusion * run);
}

